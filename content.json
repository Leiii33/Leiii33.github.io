{"meta":{"title":"横渠书馆","subtitle":"为天地立心，为生民立命，为往圣继绝学，为万世开太平","description":null,"author":"Leiii33","url":"http://leiii33.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2019-06-25T05:36:54.000Z","updated":"2019-06-25T05:38:49.527Z","comments":true,"path":"about/index.html","permalink":"http://leiii33.github.io/about/index.html","excerpt":"","text":"关于我喜欢阅读，尤其是历史方面的书籍。如春秋、东周列国志等等；从事 Java 开发； 热爱新技术、热爱新事物。 关于工作城市：成都 关于学习正在往终身学习者前进… 关于座右铭 为天地立心，为生民立命，为往圣继绝学，为万世开太平 关于爱好爱乒乓球、阅读、电影、旅行。 联系我 Email: leiyb33@gmail.com"}],"posts":[{"title":"Java单元测试","slug":"Java单元测试","date":"2019-10-12T14:07:31.000Z","updated":"2019-10-15T03:59:36.533Z","comments":true,"path":"2019/10/12/Java单元测试/","link":"","permalink":"http://leiii33.github.io/2019/10/12/Java单元测试/","excerpt":"","text":"什么是单元测测试 定义：单元测试是对软件或者程序的基本（最小）组成单元的测试对象：方法、类特点：-可重复执行；-执行速度快；-独立无依赖；-结果不改变。 为什么要写单元测试 -使我们更了解需求；-使重构更容易；-更早了解程序的问题；-快速验证；-目标明确。 测试分类 单元测试-&gt;集成测试-&gt;端到端测试各测试占比 Junit介绍 Junit例子：12345678910111213141516171819202122232425import org.junit.*;import static org.junit.Assert.fail;public class ClassNameTest &#123; @BeforeClass //公开表态无返回值 public static void beforeClass() throws Exception&#123; //每次测试类执行前执行一次，主要用来初使化公共资源等 &#125; @AfterClass //公开表态无返回值 public static void afterClass() throws Exception&#123; //每次测试类执行完成后执行一次，主要用来释放资源或清理工作 &#125; @Before public void setup() throws Exception &#123; //每个测试案例执行前都会执行一次 &#125; @After public void teardown() throws Exception &#123; //每个测试案例执行完成后都会执行一次 &#125; @Test public void testMethodName_give_…_when_…_then_…() &#123; fail(\"失败\"); &#125;&#125; 常用注解：12345678910111213141516171819202122@Ignore 该注解标记的测试方法在测试中会被忽略@Test @Test(expected=xxxException.class) 断言该方法会抛出异常 @Test(timeout=1000) 执行时间超过设置的值该案例会失败@RunWith @RunWith(Suite.class) 测试集运行器配合使用测试集功能 @RunWith(JUnit4.class) 默认运行器 @RunWith(Parameterized.class) 参数化运行器 @RunWith(Suite.class) @Suite.SuiteClasses(&#123;CalculatorTest.class,SquareTest.class&#125;)@Rulepublic class ExpectedExceptionsTest &#123; @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void verifiesTypeAndMessage() &#123; thrown.expect(RuntimeException.class); thrown.expectMessage(\"Runtime exception occurred\"); throw new RuntimeException(\"Runtime exception occurred\"); &#125;&#125; 参数化：123456789101112131415161718192021@RunWith(Parameterized.class)public class PrimeFactorTest &#123; private PrimeFactor primeFactor; private int input; private List&lt;Integer&gt; expected; //构造函数 public PrimeFactorTest(int input, List&lt;Integer&gt; expected) &#123; this.input = input; this.expected = expected; &#125; @Parameterized.Parameters public static Collection init() &#123; return Arrays.asList(new Object[][]&#123; &#123;18, Arrays.asList(2, 3, 3)&#125; &#125;); &#125; @Test public void testFactor_when_input_18_then_must_return_2_3_3() &#123; Assert.assertEquals(expected, primeFactor.factor(input)); &#125;&#125; 断言：常用的断言方法如下：123456789101112131415161718assertEquals(a, b) 测试a是否等于b（a和b是原始类型数值(primitive value)或者必须为实现比较而具有equal方法）assertFalse(a) 测试a是否为false（假），a是一个Boolean数值。assertTrue(a) 测试a是否为true（真），a是一个Boolean数值assertNotNull(a) 测试a是否非空，a是一个对象或者null。assertNull(a) 测试a是否为null，a是一个对象或者null。assertNotSame(a, b) 测试a和b是否没有都引用同一个对象。assertSame(a, b) 测试a和b是否都引用同一个对象。fail(string) Fail让测试失败，并给出指定信息。assertThat(expected, Matcher) 通过Matcher断言Hamcrest ：greaterThan，greaterThanOrEqualTo，lessThan，anything，anyOf，containsString","categories":[{"name":"Java","slug":"Java","permalink":"http://leiii33.github.io/categories/Java/"}],"tags":[{"name":"-Java -单元测试","slug":"Java-单元测试","permalink":"http://leiii33.github.io/tags/Java-单元测试/"}]},{"title":"并查集","slug":"bingchaji","date":"2019-06-25T15:50:43.000Z","updated":"2019-10-14T12:55:16.851Z","comments":true,"path":"2019/06/25/bingchaji/","link":"","permalink":"http://leiii33.github.io/2019/06/25/bingchaji/","excerpt":"","text":"问题描述：基于双亲表示法存储的折叠规则下的并查集 折叠规则：如果j是从i到根的路径上的一个节点，并且S.parents[j]≠S.root[i]，则把S.parents[j]置于S.root[i]。就是说，让j的双亲指针直接指向根。 实现：1234567891011121314//折叠规则压缩路径法//包含元素i的树中搜索根，并将从元素i到根的路径上的所有结点都变成根的结点int collapsingfind(int i)&#123; int j; for(j=i;parent[j]&gt;=0;j=parent[j]); //搜索j的根 while(i!=j) //向上逐次压缩 &#123; int temp=parent[i]; parent[i]=j; i=temp; &#125; return j; //返回根&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://leiii33.github.io/tags/并查集/"},{"name":"折叠规则","slug":"折叠规则","permalink":"http://leiii33.github.io/tags/折叠规则/"}]},{"title":"随手记","slug":"Yanzi","date":"2019-06-25T08:02:21.000Z","updated":"2019-10-15T03:57:08.024Z","comments":true,"path":"2019/06/25/Yanzi/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Yanzi/","excerpt":"","text":"负甲为兵，咋笔为吏，身死名灭者如牛毛，角立杰出者如芝草，故不得已有学之贫贱比于无学之富贵也。 运交华盖欲何求，未敢翻身已碰头。破帽遮颜过闹市，漏船载酒泛中流。横眉冷对千夫指，俯首甘为孺子牛。躲进小楼成一统，管他冬夏与春秋。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://leiii33.github.io/categories/随笔/"}],"tags":[{"name":"颜氏家训","slug":"颜氏家训","permalink":"http://leiii33.github.io/tags/颜氏家训/"}]},{"title":"数据结构-树","slug":"Tree","date":"2019-06-25T05:46:33.000Z","updated":"2019-10-14T12:59:05.194Z","comments":true,"path":"2019/06/25/Tree/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Tree/","excerpt":"","text":"问题描述： 1、树以孩子兄弟链表为数据结构，请设计算法，求树的深度。2、树以孩子兄弟链表为数据结构，请设计算法，求树的度。 实现： 1、求深度（递归）：求根节点的各个子节点的的深度，然后比较得出子节点深度的最大值，最后因为根节点的高度还没有算，所以最大值加1。2、求度：求根节点的各个子节点的度，然后与根节点的度比较，取最大值。 算法实现：123456789101112131415template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::getHeigth(childSibling&lt;ElemType&gt; *r)//递归求深度&#123; childSibling&lt;ElemType&gt; *p; if(r == NULL)&#123; return 0; &#125; else &#123; int max=0, h; for(p = FirstChild(r);p!=NULL;p = NextSibling(p))&#123; h = getHeigth(p); max = (max &lt; h) ? h : max; &#125; return max+1; &#125;&#125; 12345678910111213141516template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::Degree(childSibling&lt;ElemType&gt; *r)//递归求度&#123; if(r == NULL)&#123; return 0; &#125; else &#123; childSibling&lt;ElemType&gt; *p; int max = 0, d = 0; for(p = FirstChild(r);p!=NULL;p=NextSibling(p))&#123; d++; int sub = Degree(p); max = (sub &lt; max) ? max : sub; &#125; return (d &lt; max) ? max : d; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://leiii33.github.io/tags/树/"}],"author":"Leiii33"},{"title":"Java中的值传递和引用传递","slug":"Java中的值传递和引用传递","date":"2019-06-13T03:16:43.000Z","updated":"2019-10-14T15:36:02.284Z","comments":true,"path":"2019/06/13/Java中的值传递和引用传递/","link":"","permalink":"http://leiii33.github.io/2019/06/13/Java中的值传递和引用传递/","excerpt":"","text":"一、基本概念1、值传递 在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。 2、引用传递 引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。 3、Java数据类型 Java中有两个数据类型：基本数据类型、引用数据类型。 二、基本数据类型传递示例：1234567891011public class Test &#123; public static void change(int num)&#123; num=50; &#125; public static void main(String[] args) &#123; int a=10; System.out.println(\"调用change方法之前 a = \"+a); change(a); System.out.println(\"调用change方法之后 a = \"+a); &#125;&#125; 123输出： 调用change方法之前 a = 10 调用change方法之后 a = 10 方法调用只修改了形式参数，对实际参数没有影响。方法调用结束后，形式参数回收。 三、引用数据类型传递 示例： 12345678910111213141516171819public class Test2 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); System.out.println(p1); change(p1); System.out.println(p1); &#125; public static void change(Person p2) &#123; p2 = new Person(); &#125;&#125; /** * Person类 */class Person &#123;&#125; 123输出：Person@1d44bcfaPerson@1d44bcfa 在调用完change()方法后，Person的地址值是没有改变，变量也没有变。 四、总结值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参。所以说，Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。 参考：为什么说Java中只有值传递","categories":[{"name":"Java","slug":"Java","permalink":"http://leiii33.github.io/categories/Java/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"http://leiii33.github.io/tags/Java/"}]},{"title":"Leiii33","slug":"Leiii33","date":"2019-04-20T12:57:52.000Z","updated":"2019-10-14T15:20:12.109Z","comments":true,"path":"2019/04/20/Leiii33/","link":"","permalink":"http://leiii33.github.io/2019/04/20/Leiii33/","excerpt":"","text":"横渠书馆为天地立心，为生民立命，为往圣继绝学，为万世开太平。","categories":[],"tags":[]}]}