{"meta":{"title":"横渠书馆","subtitle":"为天地立心，为生民立命，为往圣继绝学，为万世开太平","description":null,"author":"Leiii33","url":"http://leiii33.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2019-06-25T05:36:54.000Z","updated":"2019-06-25T05:38:49.527Z","comments":true,"path":"about/index.html","permalink":"http://leiii33.github.io/about/index.html","excerpt":"","text":"关于我喜欢阅读，尤其是历史方面的书籍。如春秋、东周列国志等等；从事 Java 开发； 热爱新技术、热爱新事物。 关于工作城市：成都 关于学习正在往终身学习者前进… 关于座右铭 为天地立心，为生民立命，为往圣继绝学，为万世开太平 关于爱好爱乒乓球、阅读、电影、旅行。 联系我 Email: leiyb33@gmail.com"}],"posts":[{"title":"Java单元测试","slug":"Java单元测试","date":"2019-10-12T14:07:31.000Z","updated":"2019-10-12T15:55:27.939Z","comments":true,"path":"2019/10/12/Java单元测试/","link":"","permalink":"http://leiii33.github.io/2019/10/12/Java单元测试/","excerpt":"","text":"什么是单元测测试 定义：单元测试是对软件或者程序的基本（最小）组成单元的测试对象：方法、类特点：-可重复执行；-执行速度快；-独立无依赖；-结果不改变。 为什么要写单元测试 -使我们更了解需求；-使重构更容易；-更早了解程序的问题；-快速验证；-目标明确。 测试分类 单元测试-&gt;集成测试-&gt;端到端测试各测试占比 Junit介绍 Junit例子：12345678910111213141516171819202122232425import org.junit.*;import static org.junit.Assert.fail;public class ClassNameTest &#123; @BeforeClass //公开表态无返回值 public static void beforeClass() throws Exception&#123; //每次测试类执行前执行一次，主要用来初使化公共资源等 &#125; @AfterClass //公开表态无返回值 public static void afterClass() throws Exception&#123; //每次测试类执行完成后执行一次，主要用来释放资源或清理工作 &#125; @Before public void setup() throws Exception &#123; //每个测试案例执行前都会执行一次 &#125; @After public void teardown() throws Exception &#123; //每个测试案例执行完成后都会执行一次 &#125; @Test public void testMethodName_give_…_when_…_then_…() &#123; fail(\"失败\"); &#125;&#125; 常用注解：12345678910111213141516171819202122@Ignore 该注解标记的测试方法在测试中会被忽略@Test @Test(expected=xxxException.class) 断言该方法会抛出异常 @Test(timeout=1000) 执行时间超过设置的值该案例会失败@RunWith @RunWith(Suite.class) 测试集运行器配合使用测试集功能 @RunWith(JUnit4.class) 默认运行器 @RunWith(Parameterized.class) 参数化运行器 @RunWith(Suite.class) @Suite.SuiteClasses(&#123;CalculatorTest.class,SquareTest.class&#125;)@Rulepublic class ExpectedExceptionsTest &#123; @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void verifiesTypeAndMessage() &#123; thrown.expect(RuntimeException.class); thrown.expectMessage(\"Runtime exception occurred\"); throw new RuntimeException(\"Runtime exception occurred\"); &#125;&#125; 参数化：123456789101112131415161718192021@RunWith(Parameterized.class)public class PrimeFactorTest &#123; private PrimeFactor primeFactor; private int input; private List&lt;Integer&gt; expected; //构造函数 public PrimeFactorTest(int input, List&lt;Integer&gt; expected) &#123; this.input = input; this.expected = expected; &#125; @Parameterized.Parameters public static Collection init() &#123; return Arrays.asList(new Object[][]&#123; &#123;18, Arrays.asList(2, 3, 3)&#125; &#125;); &#125; @Test public void testFactor_when_input_18_then_must_return_2_3_3() &#123; Assert.assertEquals(expected, primeFactor.factor(input)); &#125;&#125; 断言：常用的断言方法如下：123456789101112131415161718assertEquals(a, b) 测试a是否等于b（a和b是原始类型数值(primitive value)或者必须为实现比较而具有equal方法）assertFalse(a) 测试a是否为false（假），a是一个Boolean数值。assertTrue(a) 测试a是否为true（真），a是一个Boolean数值assertNotNull(a) 测试a是否非空，a是一个对象或者null。assertNull(a) 测试a是否为null，a是一个对象或者null。assertNotSame(a, b) 测试a和b是否没有都引用同一个对象。assertSame(a, b) 测试a和b是否都引用同一个对象。fail(string) Fail让测试失败，并给出指定信息。assertThat(expected, Matcher) 通过Matcher断言Hamcrest ：greaterThan，greaterThanOrEqualTo，lessThan，anything，anyOf，containsString","categories":[],"tags":[{"name":"-Java -单元测试","slug":"Java-单元测试","permalink":"http://leiii33.github.io/tags/Java-单元测试/"}]},{"title":"并查集","slug":"bingchaji","date":"2019-06-25T15:50:43.000Z","updated":"2019-06-25T15:59:16.559Z","comments":true,"path":"2019/06/25/bingchaji/","link":"","permalink":"http://leiii33.github.io/2019/06/25/bingchaji/","excerpt":"","text":"问题描述：基于双亲表示法存储的折叠规则下的并查集 折叠规则：如果j是从i到根的路径上的一个节点，并且S.parents[j]≠S.root[i]，则把S.parents[j]置于S.root[i]。就是说，让j的双亲指针直接指向根。 实现：1234567891011121314//折叠规则压缩路径法//包含元素i的树中搜索根，并将从元素i到根的路径上的所有结点都变成根的结点int collapsingfind(int i)&#123; int j; for(j=i;parent[j]&gt;=0;j=parent[j]); //搜索j的根 while(i!=j) //向上逐次压缩 &#123; int temp=parent[i]; parent[i]=j; i=temp; &#125; return j; //返回根&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://leiii33.github.io/tags/并查集/"},{"name":"折叠规则","slug":"折叠规则","permalink":"http://leiii33.github.io/tags/折叠规则/"}]},{"title":"Test","slug":"Test","date":"2019-06-25T08:13:55.000Z","updated":"2019-06-25T15:26:21.715Z","comments":true,"path":"2019/06/25/Test/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"随手记","slug":"Yanzi","date":"2019-06-25T08:02:21.000Z","updated":"2019-06-25T15:47:50.098Z","comments":true,"path":"2019/06/25/Yanzi/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Yanzi/","excerpt":"","text":"负甲为兵，咋笔为吏，身死名灭者如牛毛，角立杰出者如芝草，故不得已有学之贫贱比于无学之富贵也。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://leiii33.github.io/categories/随笔/"}],"tags":[{"name":"颜氏家训","slug":"颜氏家训","permalink":"http://leiii33.github.io/tags/颜氏家训/"}]},{"title":"数据结构-树","slug":"Tree","date":"2019-06-25T05:46:33.000Z","updated":"2019-06-25T15:47:22.354Z","comments":true,"path":"2019/06/25/Tree/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Tree/","excerpt":"","text":"问题描述： 1、树以孩子兄弟链表为数据结构，请设计算法，求树的深度。2、树以孩子兄弟链表为数据结构，请设计算法，求树的度。 实现： 1、求深度（递归）：求根节点的各个子节点的的深度，然后比较得出子节点深度的最大值，最后因为根节点的高度还没有算，所以最大值加1。2、求度：求根节点的各个子节点的度，然后与根节点的度比较，取最大值。 算法实现：123456789101112131415template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::getHeigth(childSibling&lt;ElemType&gt; *r)//递归求深度&#123; childSibling&lt;ElemType&gt; *p; if(r == NULL)&#123; return 0; &#125; else &#123; int max=0, h; for(p = FirstChild(r);p!=NULL;p = NextSibling(p))&#123; h = getHeigth(p); max = (max &lt; h) ? h : max; &#125; return max+1; &#125;&#125; 12345678910111213141516template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::Degree(childSibling&lt;ElemType&gt; *r)//递归求度&#123; if(r == NULL)&#123; return 0; &#125; else &#123; childSibling&lt;ElemType&gt; *p; int max = 0, d = 0; for(p = FirstChild(r);p!=NULL;p=NextSibling(p))&#123; d++; int sub = Degree(p); max = (sub &lt; max) ? max : sub; &#125; return (d &lt; max) ? max : d; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://leiii33.github.io/tags/树/"}],"author":"Leiii33"},{"title":"Leiii33","slug":"Leiii33","date":"2019-04-20T12:57:52.000Z","updated":"2019-06-25T15:31:54.631Z","comments":true,"path":"2019/04/20/Leiii33/","link":"","permalink":"http://leiii33.github.io/2019/04/20/Leiii33/","excerpt":"","text":"第一第二测试呼呼呼啦啦啦","categories":[],"tags":[]}]}