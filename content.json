{"meta":{"title":"横渠书馆","subtitle":"为天地立心，为生民立命，为往圣继绝学，为万世开太平","description":null,"author":"Leiii33","url":"http://leiii33.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2019-06-25T05:36:54.000Z","updated":"2019-06-25T05:38:49.527Z","comments":true,"path":"about/index.html","permalink":"http://leiii33.github.io/about/index.html","excerpt":"","text":"关于我喜欢阅读，尤其是历史方面的书籍。如春秋、东周列国志等等；从事 Java 开发； 热爱新技术、热爱新事物。 关于工作城市：成都 关于学习正在往终身学习者前进… 关于座右铭 为天地立心，为生民立命，为往圣继绝学，为万世开太平 关于爱好爱乒乓球、阅读、电影、旅行。 联系我 Email: leiyb33@gmail.com"}],"posts":[{"title":"bingchaji","slug":"bingchaji","date":"2019-06-25T15:50:43.000Z","updated":"2019-06-25T15:57:56.744Z","comments":true,"path":"2019/06/25/bingchaji/","link":"","permalink":"http://leiii33.github.io/2019/06/25/bingchaji/","excerpt":"","text":"问题描述：基于双亲表示法存储的折叠规则下的并查集 折叠规则：如果j是从i到根的路径上的一个节点，并且S.parents[j]≠S.root[i]，则把S.parents[j]置于S.root[i]。就是说，让j的双亲指针直接指向根。 实现：1234567891011121314//折叠规则压缩路径法//包含元素i的树中搜索根，并将从元素i到根的路径上的所有结点都变成根的结点int collapsingfind(int i)&#123; int j; for(j=i;parent[j]&gt;=0;j=parent[j]); //搜索j的根 while(i!=j) //向上逐次压缩 &#123; int temp=parent[i]; parent[i]=j; i=temp; &#125; return j; //返回根&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://leiii33.github.io/tags/并查集/"},{"name":"折叠规则","slug":"折叠规则","permalink":"http://leiii33.github.io/tags/折叠规则/"}]},{"title":"Test","slug":"Test","date":"2019-06-25T08:13:55.000Z","updated":"2019-06-25T15:26:21.715Z","comments":true,"path":"2019/06/25/Test/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"随手记","slug":"Yanzi","date":"2019-06-25T08:02:21.000Z","updated":"2019-06-25T15:47:50.098Z","comments":true,"path":"2019/06/25/Yanzi/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Yanzi/","excerpt":"","text":"负甲为兵，咋笔为吏，身死名灭者如牛毛，角立杰出者如芝草，故不得已有学之贫贱比于无学之富贵也。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://leiii33.github.io/categories/随笔/"}],"tags":[{"name":"颜氏家训","slug":"颜氏家训","permalink":"http://leiii33.github.io/tags/颜氏家训/"}]},{"title":"数据结构-树","slug":"Tree","date":"2019-06-25T05:46:33.000Z","updated":"2019-06-25T15:47:22.354Z","comments":true,"path":"2019/06/25/Tree/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Tree/","excerpt":"","text":"问题描述： 1、树以孩子兄弟链表为数据结构，请设计算法，求树的深度。2、树以孩子兄弟链表为数据结构，请设计算法，求树的度。 实现： 1、求深度（递归）：求根节点的各个子节点的的深度，然后比较得出子节点深度的最大值，最后因为根节点的高度还没有算，所以最大值加1。2、求度：求根节点的各个子节点的度，然后与根节点的度比较，取最大值。 算法实现：123456789101112131415template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::getHeigth(childSibling&lt;ElemType&gt; *r)//递归求深度&#123; childSibling&lt;ElemType&gt; *p; if(r == NULL)&#123; return 0; &#125; else &#123; int max=0, h; for(p = FirstChild(r);p!=NULL;p = NextSibling(p))&#123; h = getHeigth(p); max = (max &lt; h) ? h : max; &#125; return max+1; &#125;&#125; 12345678910111213141516template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::Degree(childSibling&lt;ElemType&gt; *r)//递归求度&#123; if(r == NULL)&#123; return 0; &#125; else &#123; childSibling&lt;ElemType&gt; *p; int max = 0, d = 0; for(p = FirstChild(r);p!=NULL;p=NextSibling(p))&#123; d++; int sub = Degree(p); max = (sub &lt; max) ? max : sub; &#125; return (d &lt; max) ? max : d; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://leiii33.github.io/tags/树/"}],"author":"Leiii33"},{"title":"Leiii33","slug":"Leiii33","date":"2019-04-20T12:57:52.000Z","updated":"2019-06-25T15:31:54.631Z","comments":true,"path":"2019/04/20/Leiii33/","link":"","permalink":"http://leiii33.github.io/2019/04/20/Leiii33/","excerpt":"","text":"第一第二测试呼呼呼啦啦啦","categories":[],"tags":[]}]}