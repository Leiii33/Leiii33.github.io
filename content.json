{"meta":{"title":"横渠书馆","subtitle":"为天地立心，为生民立命，为往圣继绝学，为万世开太平","description":null,"author":"Leiii33","url":"http://yoursite.com","root":"/"},"pages":[{"title":"个人简介","date":"2019-06-25T05:36:54.000Z","updated":"2019-06-25T05:38:49.527Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我喜欢阅读，尤其是历史方面的书籍。如春秋、东周列国志等等；从事 Java 开发； 热爱新技术、热爱新事物。 关于工作城市：成都 关于学习正在往终身学习者前进… 关于座右铭 为天地立心，为生民立命，为往圣继绝学，为万世开太平 关于爱好爱乒乓球、阅读、电影、旅行。 联系我 Email: leiyb33@gmail.com"}],"posts":[{"title":"Test","slug":"Test","date":"2019-06-25T08:13:55.000Z","updated":"2019-06-25T08:26:11.687Z","comments":true,"path":"2019/06/25/Test/","link":"","permalink":"http://yoursite.com/2019/06/25/Test/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"随手记","slug":"Yanzi","date":"2019-06-25T08:02:21.000Z","updated":"2019-06-25T08:04:45.225Z","comments":true,"path":"2019/06/25/Yanzi/","link":"","permalink":"http://yoursite.com/2019/06/25/Yanzi/","excerpt":"","text":"负甲为兵，咋笔为吏，身死名灭者如牛毛，角立杰出者如芝草，故不得已有学之贫贱比于无学之富贵也。","categories":[],"tags":[]},{"title":"数据结构-树","slug":"Tree","date":"2019-06-25T05:46:33.000Z","updated":"2019-06-25T08:28:46.528Z","comments":true,"path":"2019/06/25/Tree/","link":"","permalink":"http://yoursite.com/2019/06/25/Tree/","excerpt":"","text":"问题描述： 1、树以孩子兄弟链表为数据结构，请设计算法，求树的深度。2、树以孩子兄弟链表为数据结构，请设计算法，求树的度。 实现： 1、求深度（递归）：求根节点的各个子节点的的深度，然后比较得出子节点深度的最大值，最后因为根节点的高度还没有算，所以最大值加1。2、求度：求根节点的各个子节点的度，然后与根节点的度比较，取最大值。 算法实现：123456789101112131415template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::getHeigth(childSibling&lt;ElemType&gt; *r)//递归求深度&#123; childSibling&lt;ElemType&gt; *p; if(r == NULL)&#123; return 0; &#125; else &#123; int max=0, h; for(p = FirstChild(r);p!=NULL;p = NextSibling(p))&#123; h = getHeigth(p); max = (max &lt; h) ? h : max; &#125; return max+1; &#125;&#125; 12345678910111213141516template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::Degree(childSibling&lt;ElemType&gt; *r)//递归求度&#123; if(r == NULL)&#123; return 0; &#125; else &#123; childSibling&lt;ElemType&gt; *p; int max = 0, d = 0; for(p = FirstChild(r);p!=NULL;p=NextSibling(p))&#123; d++; int sub = Degree(p); max = (sub &lt; max) ? max : sub; &#125; return (d &lt; max) ? max : d; &#125;&#125;","categories":[],"tags":[],"author":"Leiii33"},{"title":"Leiii33","slug":"Leiii33","date":"2019-04-20T12:57:52.000Z","updated":"2019-06-25T07:54:42.386Z","comments":true,"path":"2019/04/20/Leiii33/","link":"","permalink":"http://yoursite.com/2019/04/20/Leiii33/","excerpt":"","text":"第一第二测试呼呼呼啦啦啦","categories":[],"tags":[]}]}