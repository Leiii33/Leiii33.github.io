{"meta":{"title":"横渠书馆","subtitle":"为天地立心，为生民立命，为往圣继绝学，为万世开太平","description":null,"author":"Leiii33","url":"http://leiii33.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2019-06-25T05:36:54.000Z","updated":"2019-06-25T05:38:49.527Z","comments":true,"path":"about/index.html","permalink":"http://leiii33.github.io/about/index.html","excerpt":"","text":"关于我喜欢阅读，尤其是历史方面的书籍。如春秋、东周列国志等等；从事 Java 开发； 热爱新技术、热爱新事物。 关于工作城市：成都 关于学习正在往终身学习者前进… 关于座右铭 为天地立心，为生民立命，为往圣继绝学，为万世开太平 关于爱好爱乒乓球、阅读、电影、旅行。 联系我 Email: leiyb33@gmail.com"}],"posts":[{"title":"JVM:从入门到放弃","slug":"JVM-从入门到放弃","date":"2019-11-15T09:50:17.000Z","updated":"2019-11-17T15:36:51.732Z","comments":true,"path":"2019/11/15/JVM-从入门到放弃/","link":"","permalink":"http://leiii33.github.io/2019/11/15/JVM-从入门到放弃/","excerpt":"","text":"Java的口号是什么？“一次编译，到处运行！” 简单聊聊JVM我们在刚开始学习Java的时候，一定使用过javac来编译.java文件，然后使用java来运行.class文件。1.1 编译过程：.java文件是使用Java源码编译器（也就是上面说到的javac.exe）来完成的。总结一下就是由以下三个过程组成：1.2 JVM实现跨平台：通过Java源码编译器，我们成功的将.java文件生成出.class文件。这些.class文件是不能直接运行的，它不像是C/C++。这些生成的.class文件是交给JVM来解析运行的。JDK是区分操作系统的，只要你安装了JDK，那么这个JDK就可以匹配你的操作系统。JDK中的JVM是运行在操作系统上的，.class文件是运行在JVM上的，所以完全不需要担心字节码是在哪个系统操作系统上编译完成的，只要符合标准，那么就完全可以运行。这样，Java就实现了“一次编译，到处运行”。1.3 类的加载时机：生成后的.class文件中的类都会加载进JVM中吗？实际上，JVM严格的规范了哪些情况下会对类立刻进行初始化： 创建类的实例(new 的方式)。访问某个类或接口的静态变量，或者对该静态变量赋值，调用类的静态方法； 反射的方式； 初始化某个类的子类，则其父类也会被初始化； Java虚拟机启动时被标明为启动类的类，直接使用java.exe命令来运行某个主类（包含main方法的那个类）。 所以，JVM中类的加载是动态的，它不会一次性将所有的类都加载运行，而是保证程序运行的基础类（像是基类）完全加载到jvm中，至于其他类，则在需要的时候才加载。当然这是为了节省内存开销。1.4 如何将类加载到JVM中：.class文件通过类的加载器装载到JVM中。Java中的类加载器：每种加载器的工作职责： Bootstrap ClassLoader：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类； Extension ClassLoader：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/ext/*.jar或-Djava.ext.dirs指定目录下的jar包； App ClassLoader：负责记载classpath中指定的jar包及目录中class。 工作流程： 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载； 如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 其实这就是所谓的双亲委派模型。简单来说：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。优点就是可以防止内存中出现多份同样的字节码。备注：类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。1.5 JIT即时编译器JVM加载了.class文件以后，难道会逐条取出，逐条执行吗？如果是设想的这样的话，速度就太慢了。实际上，JVM有自己的想法： 将这些Java字节码重新编译优化，生成机器码，让CPU直接执行。这样编出来的代码效率会更高； 编译也是要花费时间的，我们一般对热点代码做编译，非热点代码直接解析就好了。 备注：热点代码包含(1).多次调用的方法；(2).多次执行的循环体。那么我们怎么知道是不是热点代码，我们可以通过热点探测来检测。目前的热点探测使用计数器的方式，它为每个方法准备了两类计数器： 方法调用计数器（Invocation Counter） 回边计数器（Back EdgeCounter） 在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。 拓展阅读： https://www.ibm.com/developerworks/cn/java/j-lo-classloader/ 深入探讨 Java 类加载器（还有其他不错的文章可以学习） https://zhuanlan.zhihu.com/p/28476709 JVM杂谈之JIT 1.6 JVM的内存结构我们可以来看看JVM内存结构： 堆：存放对象实例，几乎所有的对象实例都在这里分配内存； 虚拟机栈：虚拟机栈描述的是Java方法执行的内存结构：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息； 本地方法栈：本地方法栈则是为虚拟机使用到的Native方法服务； 方法区：存储已被虚拟机加载的类元数据信息(元空间)； 程序计数器：当前线程所执行的字节码的行号指示器。 1.7 工作流程： 参考文章：https://www.cnblogs.com/qiumingcheng/p/5398610.html Java程序编译和运行的过程 未完待续，嘻嘻","categories":[{"name":"Java","slug":"Java","permalink":"http://leiii33.github.io/categories/Java/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"http://leiii33.github.io/tags/Java/"}]},{"title":"MyBatis2","slug":"MyBatis2","date":"2019-10-19T15:42:07.000Z","updated":"2019-11-17T09:50:37.548Z","comments":true,"path":"2019/10/19/MyBatis2/","link":"","permalink":"http://leiii33.github.io/2019/10/19/MyBatis2/","excerpt":"","text":"三、MyBatis入门练习1.需求：(1).根据用户id（主键）查询用户信息(2).根据用户名称模糊查询用户信息(3).添加用户(4).删除用户(5).更新用户 2.环境：JDK1.9，eclipse,Mysql8.0","categories":[{"name":"-Java","slug":"Java","permalink":"http://leiii33.github.io/categories/Java/"}],"tags":[]},{"title":"MyBatis(1)","slug":"MyBatis1","date":"2019-10-18T09:14:28.000Z","updated":"2019-11-02T11:49:00.240Z","comments":true,"path":"2019/10/18/MyBatis1/","link":"","permalink":"http://leiii33.github.io/2019/10/18/MyBatis1/","excerpt":"","text":"一、原生JDBC我们首先来看一看原生的JDBC程序的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.utils;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: JdbcTest * @Description: TODO(原始的JDBC操作数据库) * @author warcaft * @date 2015-6-27 下午3:31:22 * */public class JdbcTest &#123; public static void main(String[] args) &#123; // 数据库连接 Connection connection = null; // 预编译的Statement，使用预编译的Statement提高数据库性能 PreparedStatement preparedStatement = null; // 结果 集 ResultSet resultSet = null; try &#123; // 加载数据库驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 通过驱动管理类获取数据库链接 connection = DriverManager .getConnection( \"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\", \"root\", \"root\"); // 定义sql语句 ?表示占位符 String sql = \"select * from t_user where username = ?\"; // 获取预处理statement preparedStatement = connection.prepareStatement(sql); // 设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, \"王五\"); // 向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); // 遍历查询结果集 while (resultSet.next()) &#123; System.out.println(resultSet.getString(\"id\") + \" \" + resultSet.getString(\"username\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放资源 if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 那么原生的JDBC存在哪些问题呢： 数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。解决：使用数据库连接池管理数据库连接。 将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。解决：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。 二、MyBatis1. MyBatis架构： SqlMapConfig.xml：此文件是MyBatis的全局配置文件，配置了MyBatis的运行环境等信息；mapper.xml：sql映射文件，文件中配置了操作Sql的语句。mapper.xml文件需要在SqlMapConfig.xml文件中加载。 SqlSessionFactory即会话工厂：通过MyBatis环境等配置信息构造；工厂能帮我们加载核心配置文件。加载了核心配置文件后就创建session,通过session可以对数据库进行操作。 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。Executor是执行者，我们不需要管，因为mybatis已经为我们封装好了。mybatis直接执行sql语句。 Mapped Statement也是MyBatis一个底层封装对象，它包装了MyBatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 Mapped Statement是输入与输出中间过程中产生的一些对象，通过这些对象去访问数据库。 未完待续","categories":[{"name":"-Java","slug":"Java","permalink":"http://leiii33.github.io/categories/Java/"}],"tags":[]},{"title":"Java单元测试","slug":"Java单元测试","date":"2019-10-12T14:07:31.000Z","updated":"2019-10-15T03:59:36.533Z","comments":true,"path":"2019/10/12/Java单元测试/","link":"","permalink":"http://leiii33.github.io/2019/10/12/Java单元测试/","excerpt":"","text":"什么是单元测测试 定义：单元测试是对软件或者程序的基本（最小）组成单元的测试对象：方法、类特点：-可重复执行；-执行速度快；-独立无依赖；-结果不改变。 为什么要写单元测试 -使我们更了解需求；-使重构更容易；-更早了解程序的问题；-快速验证；-目标明确。 测试分类 单元测试-&gt;集成测试-&gt;端到端测试各测试占比 Junit介绍 Junit例子：12345678910111213141516171819202122232425import org.junit.*;import static org.junit.Assert.fail;public class ClassNameTest &#123; @BeforeClass //公开表态无返回值 public static void beforeClass() throws Exception&#123; //每次测试类执行前执行一次，主要用来初使化公共资源等 &#125; @AfterClass //公开表态无返回值 public static void afterClass() throws Exception&#123; //每次测试类执行完成后执行一次，主要用来释放资源或清理工作 &#125; @Before public void setup() throws Exception &#123; //每个测试案例执行前都会执行一次 &#125; @After public void teardown() throws Exception &#123; //每个测试案例执行完成后都会执行一次 &#125; @Test public void testMethodName_give_…_when_…_then_…() &#123; fail(\"失败\"); &#125;&#125; 常用注解：12345678910111213141516171819202122@Ignore 该注解标记的测试方法在测试中会被忽略@Test @Test(expected=xxxException.class) 断言该方法会抛出异常 @Test(timeout=1000) 执行时间超过设置的值该案例会失败@RunWith @RunWith(Suite.class) 测试集运行器配合使用测试集功能 @RunWith(JUnit4.class) 默认运行器 @RunWith(Parameterized.class) 参数化运行器 @RunWith(Suite.class) @Suite.SuiteClasses(&#123;CalculatorTest.class,SquareTest.class&#125;)@Rulepublic class ExpectedExceptionsTest &#123; @Rule public ExpectedException thrown = ExpectedException.none(); @Test public void verifiesTypeAndMessage() &#123; thrown.expect(RuntimeException.class); thrown.expectMessage(\"Runtime exception occurred\"); throw new RuntimeException(\"Runtime exception occurred\"); &#125;&#125; 参数化：123456789101112131415161718192021@RunWith(Parameterized.class)public class PrimeFactorTest &#123; private PrimeFactor primeFactor; private int input; private List&lt;Integer&gt; expected; //构造函数 public PrimeFactorTest(int input, List&lt;Integer&gt; expected) &#123; this.input = input; this.expected = expected; &#125; @Parameterized.Parameters public static Collection init() &#123; return Arrays.asList(new Object[][]&#123; &#123;18, Arrays.asList(2, 3, 3)&#125; &#125;); &#125; @Test public void testFactor_when_input_18_then_must_return_2_3_3() &#123; Assert.assertEquals(expected, primeFactor.factor(input)); &#125;&#125; 断言：常用的断言方法如下：123456789101112131415161718assertEquals(a, b) 测试a是否等于b（a和b是原始类型数值(primitive value)或者必须为实现比较而具有equal方法）assertFalse(a) 测试a是否为false（假），a是一个Boolean数值。assertTrue(a) 测试a是否为true（真），a是一个Boolean数值assertNotNull(a) 测试a是否非空，a是一个对象或者null。assertNull(a) 测试a是否为null，a是一个对象或者null。assertNotSame(a, b) 测试a和b是否没有都引用同一个对象。assertSame(a, b) 测试a和b是否都引用同一个对象。fail(string) Fail让测试失败，并给出指定信息。assertThat(expected, Matcher) 通过Matcher断言Hamcrest ：greaterThan，greaterThanOrEqualTo，lessThan，anything，anyOf，containsString","categories":[{"name":"Java","slug":"Java","permalink":"http://leiii33.github.io/categories/Java/"}],"tags":[{"name":"-Java -单元测试","slug":"Java-单元测试","permalink":"http://leiii33.github.io/tags/Java-单元测试/"}]},{"title":"设计模式","slug":"设计模式","date":"2019-09-16T07:50:00.000Z","updated":"2019-10-16T13:22:16.178Z","comments":true,"path":"2019/09/16/设计模式/","link":"","permalink":"http://leiii33.github.io/2019/09/16/设计模式/","excerpt":"","text":"为什么需要设计模式？因为项目的需求是不停的改变的，为了应对这些变化，让我们的代码能够很轻松的实现解耦和拓展。如果代码一旦写好以后再不需要任何改变，那你就可以按照你自己的想法随意写代码了。 如何判断哪里需要使用设计模式工具类的代码写好以后基本上不会再改变了，一般也不会需要大的扩展了。但是有些代码是需要经常改变的，分析好代码会如何改变，然后选择合适的设计模式来优化这部分代码。 一个例子：在电商行业中，有时候需要自定义促销：比如有A、B、C、D四种类型的商品，1、要求任意两种分类商品(A、B)一起买，打九折；2、三种不同分类的商品(A、B、C)一起买，打八折；3、四种不同分类的商品(A、B、C、D)一起买，打七折； 普通实现：单独的看这个需求还是挺简单的，但是因为我们不可能一次就定义好以后需要所有类型的促销，在后续当中还需要根据实际情况自定义一些促销方式，这样代码写起来就比较困难了。拿到需求我们可以直接上手：12345678910111213141516171819public class OrderPromotion &#123; public BigDecimal promotion(Order order, int[] promotions)&#123; for(int promotion:promotions)&#123; switch (promotion)&#123; case 1: //计算该类型折扣后的价格 break; case 2: //计算该类型折扣后的价格 break; case 3: //计算该类型折扣后的价格 break; //.... &#125; &#125; return order.getResultPrice(); &#125;&#125; 从功能上来讲，上面的代码已经实现了需求，但是，实际使用起来还是很麻烦的，计算该类型折扣后的价格，单是这简单的一句注释就可能需要很多行代码才能实现。并且当我们后期需要一些新的促销活动时，需要在switch中添加需要的类型，这对于开发来说真的是太难了，并且后期维护这些代码也是巨大的麻烦。 优化：一、单一职责原则：在上面的代码当中，promotion()方法完成了所有的工作。在现实中，我们最好让一个方法只完成一个功能。所以，我们可以将上面代码中对折扣类型的判断和计算折扣价格两个功能分开完成：1234567891011121314151617181920212223242526272829303132public class OrderPromotion &#123; public BigDecimal promotion(Order order, int[] promotions)&#123; for(int promotion:promotions)&#123; switch (promotion)&#123; case 1: calculate1(order); break; case 2: calculate2(order); break; case 3: calculate3(order); break; //more promotion &#125; &#125; return order.getResultPrice(); &#125; public void calculate1(Order order)&#123; //计算使用折扣一后的价格 &#125; public void calculate2(Order order)&#123; //计算使用折扣二后的价格 &#125; public void calculate3(Order order)&#123; //计算使用折扣三后的价格 &#125; //more calculate&#125; 这样，promotion()方法中的代码就会少很多了，整个代码的可读性会大大加强。二、策略模式：策略模式的主要思想是定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。12345678910111213141516171819public class OrderPromotion &#123; public BigDecimal promotion(Order order, int[] promotions)&#123; for(int promotion:promotions)&#123; switch (promotion)&#123; case 1: new PromotionType1Calculate(order); break; case 2: new PromotionType1Calculate(order); break; case 3: new PromotionType1Calculate(order); break; //more promotion &#125; &#125; return order.getResultPrice(); &#125;&#125; 通过策略模式，我们只需要在有新的促销方式时，定义一个新的促销类，实现PromotionType1Calculate()后，在switch中添加即可。三、工厂模式：经过前两步的优化，代码已经简单许多了。但是在每次添加新的促销方式时，OrderPromotion还是需要变化的。那么我们就可以使用工厂模式将PromotionType1Calculate的实例化分离开。12345678public class OrderPromotion &#123; public BigDecimal promotion(Order order, int[] promotions)&#123; for(int promotion:promotions)&#123; PromotionFactory.getPromotionCalculate(promotion).calculate(order); &#125; return order.getResultPrice(); &#125;&#125; 1234567891011121314151617public class PromotionFactory &#123; public static PromotionCalculate getPromotionCalculate(int promotion)&#123; switch (promotion)&#123; case 1: return new PromotionType1Calculate(order); break; case 2: return new PromotionType1Calculate(order); break; case 3: return new PromotionType1Calculate(order); break; //more promotion &#125; return null; &#125;&#125; 这样，OrderPromotion就不需要再改变了，后期只需要在PromotionFactory中添加需要的促销方式即可。最后的代码实际上还有不足，每次添加新的促销方式的时候还需要修改PromotionFactory工厂类，我们还可以通过一些方法做更进一步的优化，这次就不在记述了。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://leiii33.github.io/categories/设计模式/"}],"tags":[{"name":"-设计模式","slug":"设计模式","permalink":"http://leiii33.github.io/tags/设计模式/"}]},{"title":"为什么StringBuilder不是线程安全的","slug":"为什么StringBuilder不是线程安全的","date":"2019-09-15T04:04:35.000Z","updated":"2019-10-15T14:43:02.266Z","comments":true,"path":"2019/09/15/为什么StringBuilder不是线程安全的/","link":"","permalink":"http://leiii33.github.io/2019/09/15/为什么StringBuilder不是线程安全的/","excerpt":"","text":"我们都知道：String 字符串常量StringBuffer 字符串变量（线程安全）StringBuilder 字符串变量（非线程安全)那么，为什么StringBuilder不是线程安全的。 分析StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。首先，我们可以了解一下StringBuffer和StringBuilder的异同。String,StringBuilder以及StringBuffer这三个类之间的区别下面，我们通过一段代码来看看如果我们多线程操作了StringBuilder对象会发生什么。1234567891011121314151617181920public class StringBuilderTest &#123; public static void main(String[] args) throws InterruptedException &#123; StringBuilder stringBuilder = new StringBuilder(); StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; 10; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (int j = 0; j &lt; 10000; j++)&#123; stringBuilder.append(\"a\"); stringBuffer.append(\"b\"); &#125; &#125; &#125;).start(); &#125; Thread.sleep(100); System.out.println(\"stringBuilder的长度：\"+stringBuilder.length()); System.out.println(\"stringBuffer的长度：\"+stringBuffer.length()); &#125;&#125; 在这段代码中，我们创建了10个进程，每个进程循环10000次向StringBuilder对象stringBuilder和StringBuffer对象stringBuffer中append字符a、b。如果其中没有出错的话，最后的输出字符串的长度应该是100000。但实际上的结果是：那么为什么结果会和预期的值不一样呢。我们先来看一看StringBuilder的append()方法：StringBuilder的append()方法调用的是父类AbstractStringBuilder的append()方法：我们可以看到，其中 count += len 不是一个原子操作。当多个线程同时执行的时候，取得的count值都是一样的，但是执行完加法后赋值给count，count的值只增加了1，但是实际上却是多个线程同时执行了这一步，这就是为什么结果比预计值要小的原因。同理就可以分析出StringBuffer为什么是线程安全的了。","categories":[{"name":"Java","slug":"Java","permalink":"http://leiii33.github.io/categories/Java/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"http://leiii33.github.io/tags/Java/"}]},{"title":"单一职责原则","slug":"SRP","date":"2019-09-14T13:23:08.000Z","updated":"2019-10-16T14:06:20.166Z","comments":true,"path":"2019/09/14/SRP/","link":"","permalink":"http://leiii33.github.io/2019/09/14/SRP/","excerpt":"","text":"面向对象设计的六大原则 单一职责原则（SRP） 开闭原则（OCP） 里式替换原则（LSP） 依赖倒置原则（DIP） 接口隔离原则（ISP） 迪米特原则（LOD） 掌握这些原则可以帮助我们很好的理解面向对象的概念，同时也对学习设计模式有很大的帮助。 （一）单一职责原则定义：有且仅有一个原因引起一个类的改变。简单的说，就是一个类只有一个职责。在编写代码的时候，我们要尽量做到低耦合、高内聚的特点，单一职责原则正是为了保证类与类之间的低耦合。当一个类承担多个职责的时候，导致这个类改变的原因就会有很多，就很有可能影响到别的功能，代码的维护成本也会变高。看起来，单一职责原则是一个很简单的原则，但是能够运用好也不是一件简单的事情。在实际的问题中，有很多职责之间是有所联系的，如何合理的拆分职责以满足单一职责原则也是需要好好思索的。单一职责原则的优点：类的复杂性降低，实现什么职责都有明确的定义，提高了可读性；逻辑简单，代码的可维护性也提高了；低耦合性，变更的风险降低，只会在单一的类中的修改。","categories":[{"name":"-设计模式","slug":"设计模式","permalink":"http://leiii33.github.io/categories/设计模式/"}],"tags":[]},{"title":"并查集","slug":"bingchaji","date":"2019-06-25T15:50:43.000Z","updated":"2019-10-14T12:55:16.851Z","comments":true,"path":"2019/06/25/bingchaji/","link":"","permalink":"http://leiii33.github.io/2019/06/25/bingchaji/","excerpt":"","text":"问题描述：基于双亲表示法存储的折叠规则下的并查集 折叠规则：如果j是从i到根的路径上的一个节点，并且S.parents[j]≠S.root[i]，则把S.parents[j]置于S.root[i]。就是说，让j的双亲指针直接指向根。 实现：1234567891011121314//折叠规则压缩路径法//包含元素i的树中搜索根，并将从元素i到根的路径上的所有结点都变成根的结点int collapsingfind(int i)&#123; int j; for(j=i;parent[j]&gt;=0;j=parent[j]); //搜索j的根 while(i!=j) //向上逐次压缩 &#123; int temp=parent[i]; parent[i]=j; i=temp; &#125; return j; //返回根&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/tags/数据结构/"},{"name":"并查集","slug":"并查集","permalink":"http://leiii33.github.io/tags/并查集/"},{"name":"折叠规则","slug":"折叠规则","permalink":"http://leiii33.github.io/tags/折叠规则/"}]},{"title":"随手记","slug":"Yanzi","date":"2019-06-25T08:02:21.000Z","updated":"2019-10-15T03:57:08.024Z","comments":true,"path":"2019/06/25/Yanzi/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Yanzi/","excerpt":"","text":"负甲为兵，咋笔为吏，身死名灭者如牛毛，角立杰出者如芝草，故不得已有学之贫贱比于无学之富贵也。 运交华盖欲何求，未敢翻身已碰头。破帽遮颜过闹市，漏船载酒泛中流。横眉冷对千夫指，俯首甘为孺子牛。躲进小楼成一统，管他冬夏与春秋。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://leiii33.github.io/categories/随笔/"}],"tags":[{"name":"颜氏家训","slug":"颜氏家训","permalink":"http://leiii33.github.io/tags/颜氏家训/"}]},{"title":"数据结构-树","slug":"Tree","date":"2019-06-25T05:46:33.000Z","updated":"2019-10-14T12:59:05.194Z","comments":true,"path":"2019/06/25/Tree/","link":"","permalink":"http://leiii33.github.io/2019/06/25/Tree/","excerpt":"","text":"问题描述： 1、树以孩子兄弟链表为数据结构，请设计算法，求树的深度。2、树以孩子兄弟链表为数据结构，请设计算法，求树的度。 实现： 1、求深度（递归）：求根节点的各个子节点的的深度，然后比较得出子节点深度的最大值，最后因为根节点的高度还没有算，所以最大值加1。2、求度：求根节点的各个子节点的度，然后与根节点的度比较，取最大值。 算法实现：123456789101112131415template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::getHeigth(childSibling&lt;ElemType&gt; *r)//递归求深度&#123; childSibling&lt;ElemType&gt; *p; if(r == NULL)&#123; return 0; &#125; else &#123; int max=0, h; for(p = FirstChild(r);p!=NULL;p = NextSibling(p))&#123; h = getHeigth(p); max = (max &lt; h) ? h : max; &#125; return max+1; &#125;&#125; 12345678910111213141516template&lt;class ElemType&gt;int childSiblingTree&lt;ElemType&gt;::Degree(childSibling&lt;ElemType&gt; *r)//递归求度&#123; if(r == NULL)&#123; return 0; &#125; else &#123; childSibling&lt;ElemType&gt; *p; int max = 0, d = 0; for(p = FirstChild(r);p!=NULL;p=NextSibling(p))&#123; d++; int sub = Degree(p); max = (sub &lt; max) ? max : sub; &#125; return (d &lt; max) ? max : d; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://leiii33.github.io/tags/数据结构/"},{"name":"树","slug":"树","permalink":"http://leiii33.github.io/tags/树/"}],"author":"Leiii33"},{"title":"Java中的值传递和引用传递","slug":"Java中的值传递和引用传递","date":"2019-06-13T03:16:43.000Z","updated":"2019-10-14T15:36:02.284Z","comments":true,"path":"2019/06/13/Java中的值传递和引用传递/","link":"","permalink":"http://leiii33.github.io/2019/06/13/Java中的值传递和引用传递/","excerpt":"","text":"一、基本概念1、值传递 在方法的调用过程中，实参把它的实际值传递给形参，此传递过程就是将实参的值复制一份传递到函数中，这样如果在函数中对该值（形参的值）进行了操作将不会影响实参的值。因为是直接复制，所以这种方式在传递大量数据时，运行效率会特别低下。 2、引用传递 引用传递弥补了值传递的不足，如果传递的数据量很大，直接复过去的话，会占用大量的内存空间，而引用传递就是将对象的地址值传递过去，函数接收的是原始值的首地址值。在方法的执行过程中，形参和实参的内容相同，指向同一块内存地址，也就是说操作的其实都是源数据，所以方法的执行将会影响到实际对象。 3、Java数据类型 Java中有两个数据类型：基本数据类型、引用数据类型。 二、基本数据类型传递示例：1234567891011public class Test &#123; public static void change(int num)&#123; num=50; &#125; public static void main(String[] args) &#123; int a=10; System.out.println(\"调用change方法之前 a = \"+a); change(a); System.out.println(\"调用change方法之后 a = \"+a); &#125;&#125; 123输出： 调用change方法之前 a = 10 调用change方法之后 a = 10 方法调用只修改了形式参数，对实际参数没有影响。方法调用结束后，形式参数回收。 三、引用数据类型传递 示例： 12345678910111213141516171819public class Test2 &#123; public static void main(String[] args) &#123; Person p1 = new Person(); System.out.println(p1); change(p1); System.out.println(p1); &#125; public static void change(Person p2) &#123; p2 = new Person(); &#125;&#125; /** * Person类 */class Person &#123;&#125; 123输出：Person@1d44bcfaPerson@1d44bcfa 在调用完change()方法后，Person的地址值是没有改变，变量也没有变。 四、总结值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参。所以说，Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。 参考：为什么说Java中只有值传递","categories":[{"name":"Java","slug":"Java","permalink":"http://leiii33.github.io/categories/Java/"}],"tags":[{"name":"-Java","slug":"Java","permalink":"http://leiii33.github.io/tags/Java/"}]},{"title":"Leiii33","slug":"Leiii33","date":"2019-04-20T12:57:52.000Z","updated":"2019-10-14T15:20:12.109Z","comments":true,"path":"2019/04/20/Leiii33/","link":"","permalink":"http://leiii33.github.io/2019/04/20/Leiii33/","excerpt":"","text":"横渠书馆为天地立心，为生民立命，为往圣继绝学，为万世开太平。","categories":[],"tags":[]}]}